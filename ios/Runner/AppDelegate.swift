import UIKit
import Flutter
import CallKit // Import CallKit here, crucial for CallManager

@main
@objc class AppDelegate: FlutterAppDelegate, FlutterStreamHandler {

    private var callManager: CallManager! // Declare your CallManager instance

    // Define your channel names as constants for easy modification and clarity
    private let callEventChannelName = "com.your_app_name.call_detection/call_events"
    private let callMethodChannelName = "com.your_app_name.call_detection/call_methods"

    // MARK: - FlutterStreamHandler Methods

    // This method is called when a Flutter client (e.g., your CallService in Dart) starts listening
    func onListen(withArguments arguments: Any?, eventSink events: @escaping FlutterEventSink) -> FlutterError? {
        // Set the event sink in CallManager so it can send updates back to Flutter
        callManager.setEventSink(events)
        print("[AppDelegate] onListen: Event sink set for CallManager.")

        // Immediately send any currently active calls to Flutter when it starts listening
        // This handles cases where calls might be active before Flutter UI loads or reconnects.
        DispatchQueue.main.async {
             for callInfo in self.callManager.getActiveCallInfo() {
                 events(callInfo)
             }
        }
        return nil
    }

    // This method is called when a Flutter client stops listening
    func onCancel(withArguments arguments: Any?) -> FlutterError? {
        // Remove the event sink from CallManager to prevent sending updates to a closed stream
        callManager.setEventSink(nil)
        print("[AppDelegate] onCancel: Event sink removed from CallManager.")
        return nil
    }

    // MARK: - Application Lifecycle

    override func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        // Register plugins generated by Flutter (essential for your Flutter project)
        GeneratedPluginRegistrant.register(with: self)

        // Get a reference to the Flutter view controller
        let controller: FlutterViewController = window?.rootViewController as! FlutterViewController

        // Initialize your CallManager
        callManager = CallManager()
        print("[AppDelegate] CallManager initialized.")

        // MARK: - Setup MethodChannel

        let callMethodChannel = FlutterMethodChannel(
            name: callMethodChannelName,
            binaryMessenger: controller.binaryMessenger
        )
        callMethodChannel.setMethodCallHandler { (call: FlutterMethodCall, result: @escaping FlutterResult) in
            // Handle method calls from Flutter
            switch call.method {
            case "getInitialActiveCalls":
                // Respond with any currently active call information
                let activeCalls = self.callManager.getActiveCallInfo()
                result(activeCalls)
                print("[AppDelegate] MethodChannel: 'getInitialActiveCalls' invoked. Sent \(activeCalls.count) calls.")
            default:
                // If a method is called that we don't handle, indicate it
                result(FlutterMethodNotImplemented)
            }
        }
        print("[AppDelegate] MethodChannel '\(callMethodChannelName)' setup complete.")

        // MARK: - Setup EventChannel

        let callEventChannel = FlutterEventChannel(
            name: callEventChannelName,
            binaryMessenger: controller.binaryMessenger
        )
        // Set this AppDelegate as the stream handler for the EventChannel
        callEventChannel.setStreamHandler(self)
        print("[AppDelegate] EventChannel '\(callEventChannelName)' setup complete.")

        // Call the super implementation to finish the application launch process
        return super.application(application, didFinishLaunchingWithOptions: launchOptions)
    }
}